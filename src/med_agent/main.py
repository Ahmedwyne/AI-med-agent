# main.py

from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import JSONResponse, HTMLResponse
from pydantic import BaseModel
from med_agent.crew import crew, Task, research_agent
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
import os

app = FastAPI()

class QueryRequest(BaseModel):
    query: str

class QueryResponse(BaseModel):
    answer: str

# Mount static and templates for web UI
static_dir = os.path.join(os.path.dirname(__file__), "static")
templates_dir = os.path.join(os.path.dirname(__file__), "templates")
app.mount("/static", StaticFiles(directory=static_dir), name="static")
templates = Jinja2Templates(directory=templates_dir)

@app.get("/health")
def health() -> dict:
    return {"status": "ok"}

def get_relevant_answer(user_query: str) -> str:
    """
    Runs the agent pipeline and post-processes the output to ensure relevance and citations.
    """
    try:
        # Run the RAG pipeline
        result = crew.kickoff(inputs={"query": user_query})
        
        # In newer versions of crewAI, the result is the final output string
        if isinstance(result, str):
            answer = result
        else:
            # Fallback for other return types
            answer = str(result)
            
        # Post-process: ensure answer is not empty and contains PMIDs
        if not answer or "PMID" not in answer:
            raise ValueError("No relevant, cited answer was generated by the pipeline.")
            
        return answer
    except Exception as e:
        raise ValueError(f"Error in pipeline: {str(e)}")

@app.post("/agent_query", response_model=QueryResponse)
def agent_query(req: QueryRequest) -> QueryResponse:
    try:
        answer = get_relevant_answer(req.query)
        return QueryResponse(answer=answer)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/", response_class=HTMLResponse)
def index(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})

@app.post("/ask")
def ask_query(data: QueryRequest):
    try:
        answer = get_relevant_answer(data.query)
        return JSONResponse({"result": answer})
    except Exception as e:
        return JSONResponse({"error": str(e)}, status_code=500)
